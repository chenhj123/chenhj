### count(*)的实现方式

不同的 MySQL 引擎中，count(*) 有不同的实现方式。

- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；
- 而 InnoDB 引擎，需要全盘描扫，然后累计计数。

这里需要注意的是，MyISAM 引擎如果加了 where 条件，也不能返回这么快

那为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢？

因为版本控制（MVCC），我们来看下面一个例子

```sql
//先创建一个表
create table tcount(c int) engine=InnoDB;
```

|            会话A             |             会话B              |             会话C              |
| :--------------------------: | :----------------------------: | :----------------------------: |
|            begin;            |                                |                                |
| select count(*) from tcount; |                                |                                |
|                              |                                | insert into tcount(c)value(1); |
|                              |             begin;             |                                |
|                              | insert into tcount(c)value(1); |                                |
| select count(*) from tcount; |  select count(*) from tcount;  |  select count(*) from tcount;  |
|          (返回 0 )           |           (返回 2 )            |          （返回 1 ）           |

我们知道，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以 count(*) 遍历哪一颗树都是一样的，MySQL 优化器会找到最小的那棵树来遍历。在保证逻辑正确的前提下，尽量减少描扫的数据量，是数据库系统设计的通用法则之一。

如果你用过 show table status 命令的话，就会发现这个命令的输出结果里边也有一个 ROWS 用于显示这个表当前有多少行，但是这个是采样估算得来的，官方说误差可能到 40% 到 50%，所以这个 ROWS 并不能直接使用。

小结：

1. MyISAM 表虽然 count(*) 很快，但是不支持事务；
2. show table status 命令虽然返回很快，但是不准确；
3. InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题；



### 用缓存系统保存计数

不现实，怎么说呢？

1. 不精确，可能存在 Redis 奔溃重启之后丢失数据
2. 不能保证原子性，一定会存在先计数或先插入数据，并发大则会出现问题

### 在数据库保存计数

比较符合

1. 数据库奔溃恢复不会丢失数据
2. 存在事务，保证原子性



### 不同的 count(*) 用法

**对于 count(字段) 来说，**那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。

**对于 count(主键 id) 来说**，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。

**对于 count(1) 来说**，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。

**但是 count(*) 是例外**，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。

结论是：按照效率排序的话，count(字段)<count(主键 id)<count(1)≈count(*)