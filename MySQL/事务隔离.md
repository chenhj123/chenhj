SQL 标准的事务隔离级别包括：

- 读未提交（read uncommitted）

  一个事务还没提交时，它做的变更就能被别的事务看到

- 读提交（read committed）

  一个事务提交之后，它做的变更才会被其他事务看到。

- 可重复读（repeatable read）

  一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。

- 串行化（serializable）

  顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

用一个实例试试效果：

```sql
create table t1(c int) engine=InnoDB;
insert into t1(c) values(1);
//查看事务隔离界别
select @@tx_isolation;
//设置读未提交
set session transaction isolation level read uncommitted;
//设置读提交
set session transaction isolation level read committed;
//设置可重复读
set session transaction isolation level repeatable read;
//设置串行化
set session transaction isolation level serializable;

//session 1
begin;
select * from t1;
//session 2
begin;
select * from t1;
update t1 set c=2;
//session 1
select * from t1;
//session 2
commit;
//session 1
select * from t1;
commit;
select * from t1;
```

Oracle  数据库默认的隔离级别其实是 “读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为了保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为 “读提交”。

set session 可以同时存在不同的隔离级别

### 可重复读

同一个事务中，每一次的改变都会被记录下来，每一次的记录都是一次版本，可以存在多个版本，这就是数据库的多版本控制（MVCC）。

你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？

在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 视图 的时候。

基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务

你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。

```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

